/*
 Copyright (C) 2024 Quaternion Risk Management Ltd
 All rights reserved.

 This file is part of ORE, a free-software/open-source library
 for transparent pricing and risk analysis - http://opensourcerisk.org

 ORE is free software: you can redistribute it and/or modify it
 under the terms of the Modified BSD License.  You should have received a
 copy of the license along with this program.
 The license is also available online at <http://opensourcerisk.org>

 This program is distributed on the basis that it will form a useful
 contribution to risk analytics and model standardisation, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the license for more details.
*/

/*! \file ored/scripting/engines/amccgpricingengine.hpp
    \brief pricing engine suitable to be used in amc-cg framework
*/

#pragma once

#include <ored/scripting/models/modelcg.hpp>

#include <qle/ad/computationgraph.hpp>

#include <set>
#include <string>

namespace ore {
namespace data {

struct TradeExposure {
    /* There are basically two types of trades

       - plain trades
       - individual trades

       The plain trades produce a single component path value and use a standard set of regressors including the model
       state at the simulation time for all relevant model components.  The regression is run in the exposure engine,
       i.e. outside the trade pricing engine, over all plain trades. This regression uses the union of all regressors
       of plain trades and the regressor set is grouped by the individual trade regressor sets.

       The individual trades produce one or more component path values which are combined to the target conditional
       expectation, which is already a conditional expectation, i.e. no regression is performed outside the trade
       pricing engine. The regressors can be more invovled in this case, e.g. include past simulation times and
       path dependent values.

       The component path values of individual nodes have to be placed in sequence into the computation graph, usually
       by creating dummy nodes with op = none to ensure this property, and the sub-computationgraph from the first
       node after the last component path value up to and including the targetConditionalExpectationDerivatives is
       used to recombine AAD derivative values for dynamic sensitivity calculation. For this, the component path values
       are populated with path derivatives and then the sub-computation graph is evaluated to get the resulting total
       derivative in the node targetConditionalExpectationDerivatives as a conditional expectation. The
       targetConditionalExpectation is then computed after the node targetConditionalExpectationDerivatives. If no
       distinction between targetConditionalExpectation and targetConditionalExpectationDerivatives is required, the
       latter node can be set to the former node.

       For the recombination run, all nodes on which the relevant sub-computationgraph depends will be populated from
       the forward evaluation values.

       The following tables summarizes how the fields are filled for both trade types:

                                          plain trades             individual trades

       componentPathValues                     1 entry                     n entries
       targetConditionalExpectation                 no                           yes
       regressors                                  yes                            no

       targetConditionalExpectationDerivatives      no                           yes

       The multiplier refers to the trade multiplier outside the ql instrument. All results generated by the exposure
       engine are multiplied by this value.
     */

    std::vector<std::size_t> componentPathValues;
    std::size_t targetConditionalExpectation = QuantExt::ComputationGraph::nan;
    std::set<std::size_t> regressors;

    std::size_t targetConditionalExpectationDerivatives = QuantExt::ComputationGraph::nan;

    double multiplier = 1.0;
};

struct TradeExposureMetaInfo {
    bool hasVega = false;
    std::set<std::string> relevantCurrencies;
    std::set<ModelCG::ModelParameter> relevantModelParameters;
};

class AmcCgPricingEngine {
public:
    virtual ~AmcCgPricingEngine() {}
    virtual void buildComputationGraph(const bool stickyCloseOutDateRun = false,
                                       std::vector<TradeExposure>* tradeExposure = nullptr,
                                       TradeExposureMetaInfo* tradeExposureMetaInfo = nullptr) const = 0;
};

} // namespace data
} // namespace ore
