<?xml version="1.0"?>
<ScriptLibrary>
  <Script>
    <Name>Swap</Name>
    <Script>
      <Code><![CDATA[
      NUMBER _AMC_NPV[SIZE(_AMC_SimDates)];
      NUMBER UnderlyingNpv[SIZE(_AMC_SimDates) + 1];
      NUMBER i, j, lastFixedLegIndex, lastFloatLegIndex;
      lastFixedLegIndex = SIZE(FixedLegSchedule);
      lastFloatLegIndex = SIZE(FloatLegSchedule);
      FOR i IN (SIZE(_AMC_SimDates), 1, -1) DO
        UnderlyingNpv[i] = UnderlyingNpv[i + 1];
        FOR j IN (lastFixedLegIndex, 2, -1) DO
          IF FixedLegSchedule[j] >= _AMC_SimDates[i] THEN
            UnderlyingNpv[i] = UnderlyingNpv[i] + PAY( Notional * FixedRate * dcf( FixedDayCounter, FixedLegSchedule[j-1], FixedLegSchedule[j] ),
                                                   FixedLegSchedule[j], FixedLegSchedule[j], PayCurrency );
            lastFixedLegIndex = j - 1;
          END;
        END;
        FOR j IN (lastFloatLegIndex, 2, -1) DO
          IF FloatLegSchedule[j] >= _AMC_SimDates[i] THEN
            UnderlyingNpv[i] = UnderlyingNpv[i] - PAY( Notional * (FloatIndex(FixingSchedule[j-1]) + FloatSpread) * dcf( FloatDayCounter, FloatLegSchedule[j-1], FloatLegSchedule[j] ),
                                                 FixingSchedule[j-1], FloatLegSchedule[j], PayCurrency );
            lastFloatLegIndex = j - 1;
          END;
        END;
      END;
      FOR i IN (1, SIZE(_AMC_SimDates), 1) DO
        _AMC_NPV[i] = UnderlyingNpv[i];
      END;
      value = UnderlyingNpv[1];
      FOR j IN (lastFixedLegIndex, 2, -1) DO
        value = value + PAY( Notional * FixedRate * dcf( FixedDayCounter, FixedLegSchedule[j-1], FixedLegSchedule[j] ),
                                                 FixedLegSchedule[j], FixedLegSchedule[j], PayCurrency );
      END;
      FOR j IN (lastFloatLegIndex, 2, -1) DO
        value = value - PAY( Notional * (FloatIndex(FixingSchedule[j-1]) + FloatSpread) * dcf( FloatDayCounter, FloatLegSchedule[j-1], FloatLegSchedule[j] ),
                                               FixingSchedule[j-1], FloatLegSchedule[j], PayCurrency );
      END;
      ]]></Code>
      <NPV>value</NPV>
    </Script>
  </Script>

  <!-- Cash settled European EQ, FX, COM Option                                               
   
       Inputs:                                                                            
       Expiry                          option expiry date                                     
       Settlement                      option payoff settlement date                          
       Strike                          option strike                                          
       PutCall                         1 for call, -1 for put                                 
       LongShort                       1 for a long, -1 for a short position                  
       Quantity                        number of option contracts                             
       Underlying                      underlying index                                       
       PayCcy                          payment currency                                       
  -->
  <Script>
    <Name>EuropeanOption</Name>
    <Script>
      <Code>
        <![CDATA[
          NUMBER Payoff, CurrentNotional;
          Payoff = PutCall * (Underlying(Expiry) - Strike);
          Option = LOGPAY( LongShort * Quantity * max( Payoff, 0 ), Expiry, Settlement, PayCcy, 1, OptionFlow);
          CurrentNotional = Strike * Quantity;
        ]]></Code>
      <NPV>Option</NPV>
      <Results>
        <Result rename="notionalCurrency">PayCcy</Result>
        <Result rename="currentNotional">CurrentNotional</Result>
      </Results>
      <CalibrationSpec>
        <Calibration>
          <Index>Underlying</Index>
          <Strikes>
            <Strike>Strike</Strike>
          </Strikes>
        </Calibration>
      </CalibrationSpec>
    </Script>
  </Script>

  <!-- Single Barrier Option

       Inputs:
       PayoffType                           0 = Vanilla max(0, S-K), 1 = Cash or Nothing
       LongShort                            long / short indicator, +1 for long, -1 for short position
       PutCall                              put / call indicator, +1 for call, -1 for put
       Quantity                             quantity for PayoffType = 0 (Vanilla)
       Strike                               the strike for PayoffType = 0 (Vanilla)
       Amount                               amount for PayoffType = 1 (Cash or Nothing)
       PayCcy                               payment currency
       Expiry                               option expiry date
       Settlement                           option settlement date
       Underlying                           the underlying index
       BarrierType                          1 = DonwIn, 2 = UpIn, 3 = DownOut, 4 = UpOut
       BarrierLevel                         barrier level
       BarrierRebate                        barrier rebate (only for out)
       BarrierRebateCurrency                barrier rebate currency
       BarrierRebatePayTime                 0 = atHit, 1 = atExpiry (only for out)
       BarrierMonitoringDates               list of barrier monitoring dates

       Results:
       Value                                NPV of the barrier option
       currentNotional                      current notional
       notionalCurrency                     current notional currency
  -->

  <Script>
    <Name>SingleBarrierOption</Name>
    <Script>
      <Code><![CDATA[
        REQUIRE PayoffType == 0 OR PayoffType == 1;
        NUMBER KnockedIn, KnockedOut, Active, Rebate;
        NUMBER U, i, d, CurrentNotional;

        FOR d IN (1, SIZE(BarrierMonitoringDates), 1) DO

          U = Underlying(BarrierMonitoringDates[d]);

          IF {BarrierType == 1 AND U <= BarrierLevel} OR
             {BarrierType == 2 AND U >= BarrierLevel} THEN
             IF KnockedOut == 0 THEN
               KnockedIn = 1;
	     END;
          END;

          IF {BarrierType == 3 AND U < BarrierLevel} OR
             {BarrierType == 4 AND U > BarrierLevel} THEN
            IF KnockedOut == 0 THEN
              IF BarrierRebatePayTime == 0 THEN
                Rebate = PAY( LongShort * BarrierRebate, BarrierMonitoringDates[d], BarrierMonitoringDates[d], BarrierRebateCurrency );
              ELSE
                Rebate = PAY( LongShort * BarrierRebate, BarrierMonitoringDates[d], Settlement, BarrierRebateCurrency );
              END;
            END;
            KnockedOut = 1;
          END;

        END;

        Active = 1;
        IF BarrierType == 1 OR BarrierType == 2 THEN
          Active = 0;
        END;
        
        Active = max(Active, KnockedIn) * (1 - KnockedOut);

	IF BarrierRebate != 0 THEN
	  Rebate = (1 - Active) * PAY( LongShort * BarrierRebate, Settlement, Settlement, BarrierRebateCurrency );
	END;

        IF PayoffType == 0 THEN
	  value = Active * PAY( LongShort * Quantity * max(0, PutCall * (Underlying(Expiry) - Strike)), Expiry, Settlement, PayCcy ) +
                  Rebate;
	ELSE
	  value = Active * PAY( LongShort * Amount, Expiry, Settlement, PayCcy ) +
                  Rebate;
	END;

        IF PayoffType == 0 THEN
          CurrentNotional = Quantity * Strike;
        ELSE
          CurrentNotional = Amount;
        END;
        ]]></Code>
      <NPV>value</NPV>
      <Results>
        <Result rename="notionalCurrency">PayCcy</Result>
        <Result rename="currentNotional">CurrentNotional</Result>
	<Result>Active</Result>
      </Results>
      <CalibrationSpec>
        <Calibration>
          <Index>Underlying</Index>
          <Strikes>
            <Strike>Strike</Strike>
            <Strike>BarrierLevel</Strike>
          </Strikes>
        </Calibration>
      </CalibrationSpec>
    </Script>
  </Script>

  <!-- Accumulator

       Inputs:
       Strike                          option strike
       FixingAmount                    unleveraged amount paid on each fixing date
       LongShort                       1 for a long, -1 for a short position
       Underlying                      underlying index
       PayCcy                          payment currency
       StartDate                       start date (only needed if AmericanKO = 1)
       FixingDates                     fixing valuation dates
       SettlementDates                 settlement dates
       RangeUpperBounds                upper bounds of fixing ranges
       RangeLowerBounds                lower bounds of fixing ranges
       RangeLeverages                  leverage amounts of fixing ranges
       KnockOutLevel                   knock out level
       KnockOutType                    barrier type 3=DownOut, 4=UpOut
       AmericanKO                      1 for American KO style, -1 for European KO style
       GuaranteedFixings               the number of fixings guaranteed regardless of knockout level

       Results:
       value                           npv of the option
       CurrentNotional                 current notional
       notionalCurrency                notional currency
  -->
  <Script>
    <Name>Accumulator</Name>
    <Script>
      <Code><![CDATA[
            REQUIRE KnockOutType == 3 OR KnockOutType == 4;
            NUMBER Payoff, fix, d, r, Alive, CurrentNotional, Factor, ThisPayout, Fixing[SIZE(FixingDates)];
            Alive = 1;
            FOR d IN (1, SIZE(FixingDates), 1) DO
                fix = Underlying(FixingDates[d]);
                Fixing[d] = fix;

                IF AmericanKO == 1 THEN
                  IF KnockOutType == 4 THEN
                    IF FixingDates[d] >= StartDate THEN
                       IF d == 1 OR FixingDates[d-1] <= StartDate THEN
                          Alive = Alive * (1 - ABOVEPROB(Underlying, StartDate, FixingDates[d], KnockOutLevel));
		       ELSE
                          Alive = Alive * (1 - ABOVEPROB(Underlying, FixingDates[d-1], FixingDates[d], KnockOutLevel));
		       END;
                    END;
                  ELSE
                    IF FixingDates[d] >= StartDate THEN
                       IF d == 1 OR FixingDates[d-1] <= StartDate THEN
                          Alive = Alive * (1 - BELOWPROB(Underlying, StartDate, FixingDates[d], KnockOutLevel));
		       ELSE
                          Alive = Alive * (1 - BELOWPROB(Underlying, FixingDates[d-1], FixingDates[d], KnockOutLevel));
		       END;
                    END;
                  END;
                ELSE
                  IF {KnockOutType == 4 AND fix >= KnockOutLevel} OR
                     {KnockOutType == 3 AND fix <= KnockOutLevel} THEN
                    Alive = 0;
                  END;
                END;

                IF d <= GuaranteedFixings THEN
                  Factor = 1;
                ELSE
                  Factor = Alive;
                END;

                FOR r IN (1, SIZE(RangeUpperBounds), 1) DO
                  IF fix > RangeLowerBounds[r] AND fix <= RangeUpperBounds[r] THEN
                    ThisPayout = RangeLeverages[r] * FixingAmount * (fix - Strike) * Factor;
                    IF d > GuaranteedFixings OR ThisPayout >= 0 THEN
                      Payoff = Payoff + LOGPAY(RangeLeverages[r] * FixingAmount * (fix - Strike) * Factor,
                                               FixingDates[d], SettlementDates[d], PayCcy);
                    END;
                  END;
                END;
            END;
            value = LongShort * Payoff;
            CurrentNotional = FixingAmount * Strike;
        ]]></Code>
      <NPV>value</NPV>
      <Results>
        <Result rename="notionalCurrency">PayCcy</Result>
        <Result rename="currentNotional">CurrentNotional</Result>
        <Result>Alive</Result>
        <Result>Fixing</Result>
      </Results>
      <CalibrationSpec>
        <Calibration>
          <Index>Underlying</Index>
          <Strikes>
            <Strike>Strike</Strike>
            <Strike>KnockOutLevel</Strike>
          </Strikes>
        </Calibration>
      </CalibrationSpec>
    </Script>
  </Script>

  <!-- Asian Basket EQ, FX, COM Option

       Inputs:
       Expiry                          option expiry date
       Settlement                      option payoff settlement date
       Strike                          option strike
       PutCall                         1 for call, -1 for put
       LongShort                       1 for a long, -1 for a short position
       Notional                        multiplier, number of option contracts, etc.
       Underlyings                     vector of underlying indices
       Weights                         vector of underlying weights
       PayCcy                          payment currency
       ObservationDates                observation dates

       Results:
       Option                          npv of the option
       ExerciseProbability             exercise probability of the option
       currentNotional                 current notional
       notionalCurrency                notional currency
  -->
  <Script>
    <Name>AsianBasketOption</Name>
    <Script>
      <Code><![CDATA[
      REQUIRE SIZE(Underlyings) == SIZE(Weights);

      NUMBER d, u, basketPrice, ExerciseProbability, Payoff;
      NUMBER currentNotional;

      FOR d IN (1, SIZE(ObservationDates), 1) DO
          FOR u IN (1, SIZE(Underlyings), 1) DO
              basketPrice = basketPrice + Underlyings[u](ObservationDates[d]) * Weights[u];
          END;
      END;

      basketPrice = basketPrice / SIZE(ObservationDates);

      Payoff = max(PutCall * (basketPrice - Strike), 0);

      Option = LongShort * Notional * PAY(Payoff, Expiry, Settlement, PayCcy);

      IF Payoff > 0 THEN
          ExerciseProbability = 1;
      END;

      currentNotional = Notional * Strike;
      ]]>
      </Code>
      <NPV>Option</NPV>
      <Results>
        <Result>ExerciseProbability</Result>
        <Result>currentNotional</Result>
        <Result rename="notionalCurrency">PayCcy</Result>
      </Results>
    </Script>
  </Script>
  
  <!-- TaRF

       Input Data:
       FixingAmount                    unleveraged amount paid on each fixing date
       LongShort                       1 for a long, -1 for a short position
       Underlying                      underlying index
       PayCcy                          payment currency
       FixingDates                     fixing valuation dates
       SettlementDates                 settlement dates
       RangeUpperBounds                upper bounds of fixing ranges
       RangeLowerBounds                lower bounds of fixing ranges
       RangeLeverages                  leverage amounts of fixing ranges
       RangeStrikes                    option strikes per range
       KnockOutProfitAmount            if > 0, trigger for accumulated profit
       KnockOutProfitEvents            if > 0, trigger for number of profit events
       TargetAmount                    target amount for TargetType = exact
       TargetType                      -1 for truncated, 0 for exact, 1 for full

       Result Data:
       value                           npv of the option
       currentNotional                 current notional
       notionalCurrency                notional currency
  -->
  <Script>
    <Name>TaRF</Name>
    <ProductTag>SingleAssetOption({AssetClass})</ProductTag>
    <Script>
      <Code><![CDATA[
            REQUIRE FixingAmount > 0;
            REQUIRE LongShort == 1 OR LongShort == -1;
            REQUIRE SIZE(RangeUpperBounds) == SIZE(RangeLowerBounds);
            REQUIRE SIZE(RangeLowerBounds) == SIZE(RangeLeverages);
            REQUIRE SIZE(RangeLowerBounds) == SIZE(RangeStrikes);
            REQUIRE TargetType == -1 OR TargetType == 0 OR TargetType == 1;
            REQUIRE SIZE(FixingDates) == SIZE(SettlementDates);

            NUMBER Payoff, d, r, PnL, wasTriggered, AccProfit, Hits, currentNotional;
            NUMBER Fixing[SIZE(FixingDates)], Triggered[SIZE(FixingDates)];

            FOR r IN (1, SIZE(RangeUpperBounds), 1) DO
              REQUIRE RangeLowerBounds[r] <= RangeUpperBounds[r];
              REQUIRE RangeStrikes[r] >= 0;
            END;
	    
            FOR d IN (1, SIZE(FixingDates), 1) DO
              Fixing[d] = Underlying(FixingDates[d]);
              IF wasTriggered != 1 THEN
                PnL = 0;
                FOR r IN (1, SIZE(RangeUpperBounds), 1) DO
                  IF Fixing[d] > RangeLowerBounds[r] AND Fixing[d] <= RangeUpperBounds[r] THEN
                    PnL = PnL + RangeLeverages[r] * FixingAmount * (Fixing[d] - RangeStrikes[r]);
                  END;
                END;

                IF PnL >= 0 THEN
                  AccProfit = AccProfit + PnL;
                  Hits = Hits + 1;
                END;

                IF {KnockOutProfitEvents > 0 AND Hits >= KnockOutProfitEvents} OR
                   {KnockOutProfitAmount > 0 AND AccProfit >= KnockOutProfitAmount} THEN
                  wasTriggered = 1;
                  Triggered[d] = 1;
                  IF TargetType == 0 THEN
                    Payoff = Payoff + LOGPAY(TargetAmount - (AccProfit - PnL), FixingDates[d], SettlementDates[d], PayCcy, 0, Cashflow);
                  END;
                  IF TargetType == 1 THEN
                    Payoff = Payoff + LOGPAY(PnL, FixingDates[d], SettlementDates[d], PayCcy, 0, Cashflow);
                  END;
                ELSE
                    Payoff = Payoff + LOGPAY(PnL, FixingDates[d], SettlementDates[d], PayCcy, 0, Cashflow);
                END;
              END;
            END;
            value = LongShort * Payoff;
            currentNotional = FixingAmount * RangeStrikes[1];
        ]]></Code>
      <NPV>value</NPV>
      <Results>
        <Result>currentNotional</Result>
        <Result rename="notionalCurrency">PayCcy</Result>
        <Result>Fixing</Result>
        <Result>Triggered</Result>
      </Results>
    </Script>
  </Script>
  <!-- Generic Barrier Option

       Inputs:

       PayoffType                           0 = Vanilla max(0, S-K), 1 = Cash or Nothing
       TransatlanticBarrierType             0 = none, 1 = DonwIn, 2 = UpIn, 3 = DownOut, 4 = UpOut
       TransatlanticBarrierStrictComparison 0 = default, 1 = Strict comparison, 2 = Strict or Equal
       TransatlanticBarrierLevel            transatlantic barrier level
       LongShort                            long / short indicator, +1 for long, -1 for short position
       PutCall                              put / call indicator, +1 for call, -1 for put
       Quantity                             quantity for PayoffType = 0 (Vanilla)
       Strike                               the strike for PayoffType = 0 (Vanilla)
       Amount                               amount for PayoffType = 1 (Cash or Nothing)
       PayCurrency                          payment currency
       ExpiryDate                           option expiry date
       SettlementDate                       option settlement date
       Underlying                           the underlying index
       BarrierTypes                         array of barrier types 1 = DonwIn, 2 = UpIn, 3= DownOut, 4 = UpOut
       BarrierStrictComparison              0 = default, 1 = Strict comparison, 2 = Strict or Equal
       BarrierLevels                        array of barrier levels
       BarrierRebates                       array of barrier rebates (only for out, must all be zero if at least on KI barrier
  is defined)
       BarrierRebateCurrencies              array of barrier rebate currencies
       BarrierRebatePayTimes                0 = atHit, 1 = atExpiry (only for out)
       BarrierRebate                        barrier rebate, if at least one KI barrier is defined (should be zero otherwise, use
  BarrierRebates then)
       BarrierRebateCurrency                barrier rebate currency
       TransatlanticBarrierRebate           transatlantic barrier rebate
       TransatlanticBarrierRebateCurrency   transatlantic barrier rebate currency
       KikoType                             1 = KoAlways, 2 = KoBeforeKi, 3 = KoAfterKi, should be 1 for pure KO or pure KI barrier
  configs
       BarrierMonitoringDates               list of barrier monitoring dates

       Results:

       Value                                NPV of barrier option
       currentNotional                      current notional
       notionalCurrency                     current notional currency
  -->

  <Script>
    <Name>GenericBarrierOption</Name>
    <ProductTag>SingleAssetOptionBwd({AssetClass})</ProductTag>
    <Script>
      <Code><![CDATA[
        REQUIRE PayoffType == 0 OR PayoffType == 1;
        REQUIRE SIZE(Underlyings) == SIZE(TransatlanticBarrierType);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierLevels) / SIZE(Underlyings);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebates);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebateCurrencies);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebatePayTimes);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierStrictComparison);
        REQUIRE ExpiryDate >= BarrierMonitoringDates[SIZE(BarrierMonitoringDates)];
      
        NUMBER KnockedIn, KnockedOut, Active, rebate, TransatlanticActive;
        NUMBER Exercised, Triggered, TransatlanticTriggered;
        NUMBER U, i, k, d, currentNotional, levelIndex;
      
        FOR d IN (1, SIZE(BarrierMonitoringDates), 1) DO
      
          FOR i IN (1, SIZE(BarrierTypes), 1) DO
      
            FOR k IN (1, SIZE(Underlyings), 1) DO
              U = Underlyings[k](BarrierMonitoringDates[d]);
      
              levelIndex = ((k - 1) * SIZE(BarrierTypes)) + i;            
              IF {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 1 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 2 AND U >= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 AND BarrierTypes[i] == 1 AND U < BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 ADN BarrierTypes[i] == 2 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 1 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 2 AND U >= BarrierLevels[levelIndex]} THEN
                IF KnockedOut == 0 THEN
                  KnockedIn = 1;
                  Triggered = 1;
                END;
              END;
        
              IF {{BarrierStrictComparison[i] == 0 OR BarrierStrictComparison[i] == 1} AND BarrierTypes[i] == 3 AND U < BarrierLevels[levelIndex]} OR
                {{BarrierStrictComparison[i] == 0 OR BarrierStrictComparison[i] == 1} AND BarrierTypes[i] == 4 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 3 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 4 AND U >= BarrierLevels[levelIndex]} THEN
                IF KikoType == 1 OR { KikoType == 2 AND KnockedIn == 0 } OR { KikoType == 3 AND KnockedIn == 1 } THEN
                  IF KnockedOut == 0 THEN
                    IF BarrierRebatePayTimes[i] == 0 THEN
                      rebate = PAY( LongShort * BarrierRebates[i], BarrierMonitoringDates[d], BarrierMonitoringDates[d], BarrierRebateCurrencies[i] );
                    ELSE
                      rebate = PAY( LongShort * BarrierRebates[i], BarrierMonitoringDates[d], SettlementDate, BarrierRebateCurrencies[i] );
                    END;
                  END;
                  KnockedOut = 1;
                  Triggered = 1;
                END;
              END;
      
            END;
      
          END;
      
        END;
      
        Active = 1;
        FOR i IN (1, SIZE(BarrierTypes),1) DO
          IF BarrierTypes[i] == 1 OR BarrierTypes[i] == 2 THEN
            Active = 0;
          END;
        END;
      
        Active = max(Active, KnockedIn) * (1 - KnockedOut);
      
      	IF BarrierRebate != 0 THEN
      	    rebate = (1 - Active) * PAY( LongShort * BarrierRebate, SettlementDate, SettlementDate, BarrierRebateCurrency );
      	END;
      
      	TransatlanticActive = 1;
      	TransatlanticTriggered = 0;
        FOR k IN (1, SIZE(Underlyings), 1) DO
          REQUIRE TransatlanticBarrierType[k] >= 0  AND TransatlanticBarrierType[k] <= 4;
          IF { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k] } THEN
            TransatlanticActive = 0;
      	    TransatlanticTriggered = 1;
          END;
        END;
      
      	rebate = rebate + Active * (1 - TransatlanticActive) * PAY( TransatlanticBarrierRebate, SettlementDate, SettlementDate, TransatlanticBarrierRebateCurrency );
      
        IF PayoffType == 0 AND SIZE(Underlyings) == 1 THEN
      	    value = Active * TransatlanticActive * PAY( LongShort * Quantity * max(0, PutCall * (Underlyings[1](ExpiryDate) - Strike)), ExpiryDate, SettlementDate, PayCurrency ) +
                  rebate;
      	ELSE
      	    value = Active * TransatlanticActive * PAY( LongShort * Amount, ExpiryDate, SettlementDate, PayCurrency ) +
                  rebate;
      	END;
      
        IF value > 0 THEN
          Exercised = 1;
        END;
      
        IF PayoffType == 0 THEN
          currentNotional = Quantity * Strike;
        ELSE
          currentNotional = Amount;
        END;
        ]]></Code>
      <NPV>value</NPV>
      <Results>
        <Result>currentNotional</Result>
        <Result rename="notionalCurrency">PayCurrency</Result>
        <Result>Active</Result>
        <Result>TransatlanticActive</Result>
      </Results>
      <CalibrationSpec>
        <Calibration>
          <Index>Underlying</Index>
          <Strikes>
            <Strike>Strike</Strike>
            <Strike>BarrierLevels</Strike>
          </Strikes>
        </Calibration>
      </CalibrationSpec>
    </Script>
    <Script purpose="FD">
      <Code><![CDATA[
        REQUIRE PayoffType == 0 OR PayoffType == 1;
        REQUIRE SIZE(Underlyings) == SIZE(TransatlanticBarrierType);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierLevels) / SIZE(Underlyings);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebates);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebateCurrencies);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebatePayTimes);
        REQUIRE ExpiryDate >= BarrierMonitoringDates[SIZE(BarrierMonitoringDates)];
      
        NUMBER V, V_V, V_NA, V_KI, V_KO, V_KIKO, V_KOKI;
        NUMBER R, R_V, R_NA, R_KI, R_KO, R_KIKO, R_KOKI, rebate;
        NUMBER U, i, k, d, currentNotional, TransatlanticActive, IsKnockedIn, IsKnockedOut, levelIndex;
      
        IF PayoffType == 0 AND SIZE(Underlyings) == 1 THEN
          V = PAY( LongShort * Quantity * max(0, PutCall * (Underlyings[1](ExpiryDate) - Strike)), ExpiryDate, SettlementDate, PayCurrency );
        ELSE
          V = PAY( LongShort * Amount, ExpiryDate, SettlementDate, PayCurrency );
        END;
      
        TransatlanticActive = 1;
        FOR k IN (1, SIZE(Underlyings), 1) DO
          REQUIRE TransatlanticBarrierType[k] >= 0  AND TransatlanticBarrierType[k] <= 4;
          IF { {TransatlanticBarrierStrictComparison[k] == 0 OR TransatlanticBarrierStrictComparison[k] == 2} AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k]  } OR
            { {TransatlanticBarrierStrictComparison[k] == 0 OR TransatlanticBarrierStrictComparison[k] == 2} AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k]  } OR
            { {TransatlanticBarrierStrictComparison[k] == 0 OR TransatlanticBarrierStrictComparison[k] == 1} AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k] } OR
            { {TransatlanticBarrierStrictComparison[k] == 0 OR TransatlanticBarrierStrictComparison[k] == 1} AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k] } THEN
              TransatlanticActive = 0;
          END;
        END;
      
        IF TransatlanticActive == 0 THEN
          V = PAY( LongShort * TransatlanticBarrierRebate, ExpiryDate, SettlementDate, TransatlanticBarrierRebateCurrency );
        END;
      
        V_V = V;
        V_NA = V;
        V_KI = V * 0;
        V_KO = V * 0;
        V_KIKO = V * 0;
        V_KOKI = V * 0;
      
        R = PAY( LongShort * BarrierRebate, ExpiryDate, SettlementDate, BarrierRebateCurrency);
        R_V = R;
        R_NA = R;
        R_KI = R * 0;
        R_KO = R * 0;
        R_KIKO = R * 0;
        R_KOKI = R * 0;
      
        FOR i IN (1, SIZE(BarrierTypes), 1) DO
          IF BarrierTypes[i] == 1 OR BarrierTypes[i] == 2 THEN
            V_V = V_V * 0;
      	      R_V = R_V * 0;
          END;
        END;
      
        FOR d IN (SIZE(BarrierMonitoringDates), 1, -1) DO
      
          V_V = NPV(V_V, BarrierMonitoringDates[d]);
          V_NA = NPV(V_NA, BarrierMonitoringDates[d]);
          V_KI = NPV(V_KI, BarrierMonitoringDates[d]);
          V_KO = NPV(V_KO, BarrierMonitoringDates[d]);
          V_KIKO = NPV(V_KIKO, BarrierMonitoringDates[d]);
          V_KOKI = NPV(V_KOKI, BarrierMonitoringDates[d]);
          R_V = NPV(R_V, BarrierMonitoringDates[d]);
          R_NA = NPV(R_NA, BarrierMonitoringDates[d]);
          R_KI = NPV(R_KI, BarrierMonitoringDates[d]);
          R_KO = NPV(R_KO, BarrierMonitoringDates[d]);
          R_KIKO = NPV(R_KIKO, BarrierMonitoringDates[d]);
          R_KOKI = NPV(R_KOKI, BarrierMonitoringDates[d]);
      	    rebate = NPV(rebate, BarrierMonitoringDates[d]);
      
          FOR i IN (1, SIZE(BarrierTypes), 1) DO
      
            IsKnockedIn = 0;
            IsKnockedOut = 0;
            FOR k IN (1, SIZE(Underlyings), 1) DO
              U = Underlyings[k](BarrierMonitoringDates[d]);
              levelIndex = ((k - 1) * SIZE(BarrierTypes)) + i;
              IF {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 1 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 2 AND U >= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 AND BarrierTypes[i] == 1 AND U < BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 AND BarrierTypes[i] == 2 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 1 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 2 AND U >= BarrierLevels[levelIndex]} THEN
                IsKnockedIn = 1;
              END;
              IF {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 3 AND U < BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 4 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 AND BarrierTypes[i] == 3 AND U < BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 AND BarrierTypes[i] == 4 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 3 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 4 AND U >= BarrierLevels[levelIndex]} THEN
                IsKnockedOut = 1;
              END;

            END;
      
         IF {IsKnockedIn == 1} THEN
           V_KIKO = V_KO + V_KIKO + V_KOKI;
           V_KOKI = V_KOKI * 0;
           V_KI = V_NA + V_KI;
           V_KO = V_KO * 0;
           V_NA = V_NA * 0;
           V_V = V_KI;
           IF KikoType == 2 THEN
             V_V = V_V + V_KIKO;
           END;
           R_KIKO = R_KO + R_KIKO + R_KOKI;
           R_KOKI = R_KOKI * 0;
           R_KI = R_NA + R_KI;
           R_KO = R_KO * 0;
           R_NA = R_NA * 0;
           R_V = R_KI;
           IF KikoType == 2 THEN
             R_V = R_V + R_KIKO;
           END;
         END;
      
         IF {IsKnockedOut == 1} THEN
           V_KOKI = V_KI + V_KOKI + V_KIKO;
           V_KIKO = V_KIKO * 0;
           V_KO = V_NA + V_KO;
           V_KI = V_KI * 0;
           V_NA = V_NA * 0;
           IF KikoType == 1 OR KikoType == 2 THEN
             V_V = V_V * 0;
           END;
           R_KOKI = R_KI + R_KOKI + R_KIKO;
           R_KIKO = R_KIKO * 0;
           R_KO = R_NA + R_KO;
           R_KI = R_KI * 0;
           R_NA = R_NA * 0;
           IF KikoType == 1 OR KikoType == 2 THEN
             R_V = R_V * 0;
           END;
           IF BarrierRebatePayTimes[i] == 0 THEN
             rebate = PAY( LongShort * BarrierRebates[i], BarrierMonitoringDates[d], BarrierMonitoringDates[d], BarrierRebateCurrencies[i] );
           ELSE
             rebate = PAY( LongShort * BarrierRebates[i], BarrierMonitoringDates[d], SettlementDate, BarrierRebateCurrencies[i] );
           END;
         END;     
        END;    
      END;
      
      rebate = NPV(rebate, TODAY);
      R_V = NPV(R_V, TODAY);
      V_V = NPV(V_V, TODAY);
      
      
     rebate = rebate + ( PAY( LongShort * BarrierRebate, TODAY, SettlementDate, BarrierRebateCurrency ) - R_V );
     value = V_V + rebate;
      
      IF PayoffType == 0 THEN
        currentNotional = Quantity * Strike;
      ELSE
        currentNotional = Amount;
      END;
        ]]></Code>
      <NPV>value</NPV>
      <Results>
        <Result>currentNotional</Result>
        <Result rename="notionalCurrency">PayCurrency</Result>
      </Results>
      <CalibrationSpec>
        <Calibration>
          <Index>Underlying</Index>
          <Strikes>
            <Strike>Strike</Strike>
            <Strike>BarrierLevels</Strike>
          </Strikes>
        </Calibration>
      </CalibrationSpec>
    </Script>
    <Script purpose="AMC">
      <Code><![CDATA[
        REQUIRE PayoffType == 0 OR PayoffType == 1;
        REQUIRE SIZE(Underlyings) == SIZE(TransatlanticBarrierType);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierLevels) / SIZE(Underlyings);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebates);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebateCurrencies);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierRebatePayTimes);
        REQUIRE SIZE(BarrierTypes) == SIZE(BarrierStrictComparison);
        REQUIRE ExpiryDate >= BarrierMonitoringDates[SIZE(BarrierMonitoringDates)];
        NUMBER _AMC_NPV[SIZE(_AMC_SimDates)];
        NUMBER KnockedInTimes[SIZE(BarrierMonitoringDates)], KnockedOutTimes[SIZE(BarrierMonitoringDates)];
        NUMBER RebatePayments[SIZE(BarrierMonitoringDates)];
        NUMBER KnockedIn, KnockedOut, Active, rebate, TransatlanticActive;
        NUMBER OptionAfterKI; ActiveAfterKI;
        NUMBER transatlanticRebate, exerciseValue;
        NUMBER Exercised, Triggered, TransatlanticTriggered;
        NUMBER U, i, k, d, currentNotional, levelIndex;
        
      
        FOR d IN (1, SIZE(BarrierMonitoringDates), 1) DO
      
          FOR i IN (1, SIZE(BarrierTypes), 1) DO
      
            FOR k IN (1, SIZE(Underlyings), 1) DO
              U = Underlyings[k](BarrierMonitoringDates[d]);
      
              levelIndex = ((k - 1) * SIZE(BarrierTypes)) + i;            
              IF {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 1 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 0 AND BarrierTypes[i] == 2 AND U >= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 AND BarrierTypes[i] == 1 AND U < BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 1 ADN BarrierTypes[i] == 2 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 1 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 2 AND U >= BarrierLevels[levelIndex]} THEN
                IF KnockedOut == 0 THEN
                  KnockedIn = 1;
                  Triggered = 1;
                END;
              END;
        
              IF {{BarrierStrictComparison[i] == 0 OR BarrierStrictComparison[i] == 1} AND BarrierTypes[i] == 3 AND U < BarrierLevels[levelIndex]} OR
                {{BarrierStrictComparison[i] == 0 OR BarrierStrictComparison[i] == 1} AND BarrierTypes[i] == 4 AND U > BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 3 AND U <= BarrierLevels[levelIndex]} OR
                {BarrierStrictComparison[i] == 2 AND BarrierTypes[i] == 4 AND U >= BarrierLevels[levelIndex]} THEN
                IF KikoType == 1 OR { KikoType == 2 AND KnockedIn == 0 } OR { KikoType == 3 AND KnockedIn == 1 } THEN
                  IF KnockedOut == 0 THEN
                    IF BarrierRebatePayTimes[i] == 0 THEN
                      rebate = PAY( LongShort * BarrierRebates[i], BarrierMonitoringDates[d], BarrierMonitoringDates[d], BarrierRebateCurrencies[i] );
                    ELSE
                      rebate = PAY( LongShort * BarrierRebates[i], BarrierMonitoringDates[d], SettlementDate, BarrierRebateCurrencies[i] );
                    END;
                  END;
                  KnockedOut = 1;
                  Triggered = 1;
                END;
              END;
            END;
          END;
          KnockedInTimes[d] = KnockedIn;
          KnockedOutTimes[d] = KnockedOut;
        END;
      
        Active = 1;
        FOR i IN (1, SIZE(BarrierTypes),1) DO
          IF BarrierTypes[i] == 1 OR BarrierTypes[i] == 2 THEN
            Active = 0;
          END;
        END;
        
        Active = max(Active, KnockedIn) * (1 - KnockedOut);
        ActiveAfterKI = (1 - KnockedOut);
      	IF BarrierRebate != 0 THEN
      	    rebate = (1 - Active) * PAY( LongShort * BarrierRebate, SettlementDate, SettlementDate, BarrierRebateCurrency );
      	END;
      
      	TransatlanticActive = 1;
      	TransatlanticTriggered = 0;
        FOR k IN (1, SIZE(Underlyings), 1) DO
          REQUIRE TransatlanticBarrierType[k] >= 0  AND TransatlanticBarrierType[k] <= 4;
          IF { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 0 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) < TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 1 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) > TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 1 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 2 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k]  } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 3 AND Underlyings[k](ExpiryDate) <= TransatlanticBarrierLevel[k] } OR
            { TransatlanticBarrierStrictComparison[k] == 2 AND TransatlanticBarrierType[k] == 4 AND Underlyings[k](ExpiryDate) >= TransatlanticBarrierLevel[k] } THEN
            TransatlanticActive = 0;
      	    TransatlanticTriggered = 1;
          END;
        END;
      
        transatlanticRebate = Active * (1 - TransatlanticActive) * PAY( TransatlanticBarrierRebate, SettlementDate, SettlementDate, TransatlanticBarrierRebateCurrency );
        OptionAfterKI = ActiveAfterKI * (1 - TransatlanticActive) * PAY( TransatlanticBarrierRebate, SettlementDate, SettlementDate, TransatlanticBarrierRebateCurrency );

        IF PayoffType == 0 AND SIZE(Underlyings) == 1 THEN
      	    exerciseValue = Active * TransatlanticActive * PAY( LongShort * Quantity * max(0, PutCall * (Underlyings[1](ExpiryDate) - Strike)), ExpiryDate, SettlementDate, PayCurrency );
            OptionAfterKI = OptionAfterKI + ActiveAfterKI * TransatlanticActive * PAY( LongShort * Quantity * max(0, PutCall * (Underlyings[1](ExpiryDate) - Strike)), ExpiryDate, SettlementDate, PayCurrency );
      	ELSE
      	    exerciseValue = Active * TransatlanticActive * PAY( LongShort * Amount, ExpiryDate, SettlementDate, PayCurrency );
            OptionAfterKI = OptionAfterKI + ActiveAfterKI * TransatlanticActive * PAY( LongShort * Amount, ExpiryDate, SettlementDate, PayCurrency );
      	END;
      
        value = exerciseValue + rebate + transatlanticRebate;

        IF value > 0 THEN
          Exercised = 1;
        END;
      
        IF PayoffType == 0 THEN
          currentNotional = Quantity * Strike;
        ELSE
          currentNotional = Amount;
        END;

        FOR i IN(SIZE(_AMC_SimDates), 1, -1) DO
            s = DATEINDEX(BarrierMonitoringDates, _AMC_SimDates[i], GEQ);
            IF s > SIZE(BarrierMonitoringDates) THEN
              s = SIZE(BarrierMonitoringDates);
            END;
            IF KnockoutTimes[s] == 1 THEN
              _AMC_SimDates[i] = 0;
            ELSE
              IF KnockInTimes[s] == 1 THEN
                _AMC_SimDates[i]  = NPVMEM(OptionAfterKI, _AMC_SimDates[i], ExpiryDate, i,  KnockInTimes[s] == 1 AND KnockOutTimes[s] == 0 );
              ELSE
                _AMC_SimDates[i]  = NPVMEM(value, _AMC_SimDates[i], ExpiryDate, SIZE(_AMC_Simdates) + i, KnockInTimes[s] == 0 AND KnockOutTimes[s] == 0);
              END;
            END;
        END;
        ]]></Code>
      <NPV>value</NPV>
      <NewSchedules>
        <NewSchedule>
          <Name>MonitorAndSimDates</Name>
          <Operation>Join</Operation>
          <Schedules>
            <Schedule>_AMC_SimDates</Schedule>
            <Schedule>BarrierMonitoringDates</Schedule>
          </Schedules>
        </NewSchedule>
      </NewSchedules>
    </Script>
  </Script>
</ScriptLibrary>
